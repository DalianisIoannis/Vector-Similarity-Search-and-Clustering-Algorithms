#include "../headers/kMeans.h"

cluster::cluster()
{
    cout<<"I've just created cluster." <<endl;
}

cluster::~cluster()
{
    cout <<"I'm destroying cluster"<<endl;

}

KMeans::KMeans(const int num):numOfclusters(num)
{
    cout<<"I've just created KMeans." <<endl;

    this->clusterAr = new vector<cluster*> (this->numOfclusters);
}

KMeans::~KMeans()
{
    cout <<"I'm destroying KMeans"<<endl;

    delete this->clusterAr;
}

int KMeans::getClusNum() {
    return this->numOfclusters;
}

bool isIdInVector(const int ID, vector<inputForm*> *centrAr, const int enteredNums) {
    for (int i = 0; i < enteredNums; i++) {
        if(ID == (*centrAr)[i]->Id) {
            return true;
        }
    }
    return false;
}

// initial centroids
vector<inputForm*>* KMeans::getKMeansCentroids(dataInput* data) {
    vector<inputForm*> *centrAr = new vector<inputForm*>(this->getClusNum());

    std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_int_distribution<> distrib(0, data->getiMageVectorSize()-1);

    // uniformly choose first centroid
    int t=1;    // num of centroids so far
    int dataSize = data->getiMageVectorSize(); // num of vectors
    
    cout << "Size einai " << dataSize << endl;
    
    int un = distrib(gen);
    un = 0;
    cout << "For index " << un << " got id " << data->getinputFormByNum(un)->Id << endl;
    // for (int n=0; n<10; ++n)
    //     //Use `distrib` to transform the random unsigned int generated by gen into an int in [1, 6]
    //     std::cout << distrib(gen) << ' ';
    // std::cout << '\n';

    (*centrAr)[t-1] = (data->getinputFormByNum(un)); // first centroid

    while(t < this->getClusNum()) { // until all centroids are chosen

        cout << "For t " << t << endl;

        vector<int> *D = new vector<int>(dataSize - t); // array of min dis from vec to centroids
        
        int Dpointer = 0;
        for (int i = 0; i < dataSize; i++) {
            
            // is not centroid
            if(isIdInVector(data->getinputFormByNum(i)->Id, centrAr, t) == false) {
                // cout << i << " no found" << endl;
                (*D)[Dpointer] = manhattanDistance( &(data->getinputFormByNum(i)->image), &((*centrAr)[0]->image) );
                for (int j = 1; j < t; j++) {
                    int manhat = manhattanDistance( &(data->getinputFormByNum(i)->image), &((*centrAr)[j]->image) );
                    if(manhat<(*D)[Dpointer]) {
                        (*D)[Dpointer] = manhat;
                    }
                }

                cout << "manh for " << i << " is " << (*D)[Dpointer] << endl;

                Dpointer++;
            }
        }

        // compute probs
        Dpointer--;
        vector<float> *P = new vector<float>(Dpointer);
        
        // find max D
        int curMax = (*D)[0];
        for (int i = 1; i < Dpointer; i++) {
            if( curMax < (*D)[i] ) {
                curMax = (*D)[i];
            }
        }
        // EDOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
        (*centrAr)[t] = (data->getinputFormByNum(++un));

        t++;
        
        delete P;
        delete D;
    }

    cout << "IN THE END" << endl;
    for(int i=0; i<this->getClusNum(); i++) {
        cout << (*centrAr)[i]->Id << endl;
    }

    return centrAr;
}

void KMeans::Clusterify(dataInput* data) {

    // initial centroids
    vector<inputForm*> *centrAr = this->getKMeansCentroids(data);

    // for (unsigned int i = 0; i < 2; i++) {
    //     cout << "THIS IS IMAGE " << i << endl;
    //     for (unsigned int j = 20; j < 90; j++){ cout << "BIT " << j << " " << data->getinputFormByNum(i)->image[j] << endl; }
    // }

 
    delete centrAr;
}